// Principle states of the single elevator:
// IDLE
// GOING_UP
// GOING_DOWN


// "Technical" states:
// MOVING
// DOOR_OPENING
// DOOR_CLOSING

// External commands:
// ORDER_UP
// ORDER_DOWN

// Internal commands:
// CHOOSE_FLOOR(number)
// CLOSE_DOOR
// OPEN_DOOR

enum PrincipalState{
    IDLE="IDLE",
    GOING_UP="GOING_UP",
    GOING_DOWN="GOING_DOWN"
}

enum TechnicalState{
    MOVING='MOVING',
    WAITING='WAITING',
    DOOR_OPENING = 'DOOR_OPENING',
    DOOR_CLOSING= 'DOOR_CLOSING'

}

class Elevator{
    principalState:PrincipalState = PrincipalState.IDLE
    technicalState:TechnicalState = TechnicalState.WAITING

    orderedFloors:number[]=[]
    floorRange:number[]=[]

    constructor(floorRange:number[]){
        this.floorRange = floorRange
    }

    //internal commands
    chooseFloor(floor:number){

    }

    openDoor(){

    }

    closeDoor(){

    }

    //external commands
    orderUp(){

    }

    orderDown(){
        
    }
}

//////////////


import type { PrincipalState, TechnicalStateEnum } from "./types"

// External commands:
// ORDER_UP
// ORDER_DOWN

// Internal commands:
// CHOOSE_FLOOR(number)
// CLOSE_DOOR
// OPEN_DOOR



// Class for the DesignatedUp state
class DesignatedUp implements PrincipalState {
    context!:Elevator
    constructor(context:Elevator){
        this.context = context
    }
    chooseFloor(floor: number): void {
        // Empty implementation
    }

    openDoor(): void {
        // Empty implementation
    }

    closeDoor(): void {
        // Empty implementation
    }

    orderUp(): void {
        // Empty implementation
    }

    orderDown(): void {
        // Empty implementation
    }
}

// Class for the DesignatedDown state
class DesignatedDown implements PrincipalState {
    context!:Elevator
    constructor(context:Elevator){
        this.context = context
    }
    chooseFloor(floor: number): void {
        // Empty implementation
    }

    openDoor(): void {
        // Empty implementation
    }

    closeDoor(): void {
        // Empty implementation
    }

    orderUp(): void {
        // Empty implementation
    }

    orderDown(): void {
        // Empty implementation
    }
}

// Class for the Idle state
class Idle implements PrincipalState {
    context!:Elevator
    constructor(context:Elevator){
        this.context = context
    }
    chooseFloor(floor: number): void {

        // Empty implementation
    }

    openDoor(): void {
        // Empty implementation
    }

    closeDoor(): void {
        // Empty implementation
    }

    orderUp(): void {
        // Empty implementation
    }

    orderDown(): void {
        // Empty implementation
    }
}




class Elevator {
    private principalState!: PrincipalState
    private technicalState!: TechnicalStateEnum 
    private orderedFloors: Set<number> = new Set()
    private floorRange: number[] = []
    private currentFloor:number = 0

    constructor(principalState:PrincipalState,technicalState:TechnicalStateEnum,floorRange: number[]) {
        this.principalState = principalState
        this.technicalState = technicalState
        this.floorRange = floorRange
        
    }

    switchState(state:PrincipalState){
        this.principalState = state
    }

    //internal commands
    chooseFloor(floor: number) {
        this.orderedFloors.add(floor)
        this.principalState.chooseFloor(floor)
    }

    openDoor() {
        this.principalState.openDoor()
    }

    closeDoor() {
        this.principalState.closeDoor()
    }

    //external commands
    orderUp() {
        this.principalState.orderUp()
    }

    orderDown() {
        this.principalState.orderDown()
    }
}


const registerEvents = ()=>{
  elevator.on(ElevatorEventsEnum.CHOSEN_FLOORS_FROM_ELEVATOR_ADDED, (data) => {
    console.log(`Event ${ElevatorEventsEnum.CHOSEN_FLOORS_FROM_ELEVATOR_ADDED} emitted`, data);
  });
  elevator.on(ElevatorEventsEnum.DOOR_CLOSED, (data) => {
    // console.log(`Event ${ElevatorEventsEnum.DOOR_CLOSED} emitted`, data);
  });
  elevator.on(ElevatorEventsEnum.DOOR_CLOSING, (data) => {
    // console.log(`Event ${ElevatorEventsEnum.DOOR_CLOSING} emitted`, data);
  });
  elevator.on(ElevatorEventsEnum.DOOR_CLOSING_CANCELED, (data) => {
    console.log(`Event ${ElevatorEventsEnum.DOOR_CLOSING_CANCELED} emitted`, data);
  });
  elevator.on(ElevatorEventsEnum.DOOR_OPENED, (data) => {
    // console.log(`Event ${ElevatorEventsEnum.DOOR_OPENED} emitted`, data);
  });
  elevator.on(ElevatorEventsEnum.DOOR_OPENING, (data) => {
    // console.log(`Event ${ElevatorEventsEnum.DOOR_OPENING} emitted`, data);
  });
  elevator.on(ElevatorEventsEnum.FLOORS_AWAITING_DOWN_ADDED, (data) => {
    console.log(`Event ${ElevatorEventsEnum.FLOORS_AWAITING_DOWN_ADDED} emitted`, data);
  });
  elevator.on(ElevatorEventsEnum.FLOORS_AWAITING_UP_ADDED, (data) => {
    console.log(`Event ${ElevatorEventsEnum.FLOORS_AWAITING_UP_ADDED} emitted`, data);
  });
  elevator.on(ElevatorEventsEnum.MOVING_DOWN, (data) => {
    console.log(`Event ${ElevatorEventsEnum.MOVING_DOWN} emitted`, data);
  });
  elevator.on(ElevatorEventsEnum.MOVING_UP, (data) => {
    console.log(`Event ${ElevatorEventsEnum.MOVING_UP} emitted`, data);
  });
  elevator.on(ElevatorEventsEnum.STATIONARY, (data) => {
    // console.log(`Event ${ElevatorEventsEnum.STATIONARY} emitted`, data);
  });
  elevator.on(ElevatorEventsEnum.TECHNICAL_STATE_CHANGE, (data) => {
    console.log(`Event ${ElevatorEventsEnum.TECHNICAL_STATE_CHANGE} emitted`, data);
  });
}


async processDirection(direction:'DESIGNATED_UP'|'DESIGNATED_DOWN'){
    let queue:string;
    let floorAddition:number
    let oppositeDirection:string
    if(direction === 'DESIGNATED_DOWN'){
        queue = this.downQueue
        floorAddition = -1
        oppositeDirection = 'DESIGNATED_UP'
    }else{
        queue = this.upQueue
        floorAddition = 1
        oppositeDirection = 'DESIGNATED_DOWN'
    }

    while (queue.length) {
        // await delay(2000) // This line is commented out as in processUpState
        const nextFloor = this.currentFloor + floorAddition
        const nextFloorToStop = queue.peek();
        await delay(1000);
        this.emit(ElevatorEventsEnum.CURRENT_FLOOR, nextFloor);
        
        this.currentFloor = nextFloor;
        if (nextFloor === nextFloorToStop) {
            queue.dequeue();
            this.emit(ElevatorEventsEnum.STOPPING_AT_FLOOR,nextFloorToStop)
            await delay(3000); // Simulate the time taken to stop at a floor
        }
    }
    const newState = queue.length ? PrincipalStateEnum[oppositeDirection] : PrincipalStateEnum.IDLE;
    this.emit(ElevatorEventsEnum.DOWN_QUEUE_FINISHED);
    this.switchPrincipalState(newState);
}